# AI駆動リファクタリングワークフロー — MOKU

このドキュメントは、AIを活用した効率的なリファクタリング手法を定義します。  
ドキュメントファーストのアプローチで、想定動作とのずれを最小化しながら品質向上を実現します。

---

## 📋 目次
1. [基本方針](#基本方針)
2. [効率的なリファクタリング手法](#効率的なリファクタリング手法)
3. [ドキュメント活用戦略](#ドキュメント活用戦略)
4. [具体的なワークフロー](#具体的なワークフロー)
5. [チェックポイント](#チェックポイント)

---

## 基本方針

### **1. ドキュメントファースト戦略**

AIに作業を依頼する際は、**必ず関連ドキュメントを参照させる**。

```
【悪い例】
❌ 「useParticipants.js のLintエラーを修正して」

【良い例】
✅ 「@docs/CODING_RULES.md @docs/ARCHITECTURE.md を参照して、
    @src/features/collaboration/hooks/useParticipants.js の
    Lintエラーを修正してください。既存の動作を変えないこと。」
```

### **2. 自動検出ツール活用**

手動でバグや問題を探すのではなく、**自動検出ツールを最大限活用**する。

```
優先順位:
1. npm run lint          ← コード品質の問題を自動検出
2. npm run build:dev     ← ビルドエラーを検出
3. ブラウザコンソール    ← ランタイムエラーを検出
4. ドキュメントとの照合  ← 仕様のずれを検出
```

### **3. 段階的な改善**

一度に全てを修正せず、**小さな単位で確実に改善**する。

```
Phase 1: 環境設定の修正（5分）
  ↓ 検証: npm run lint
Phase 2: 高優先度エラーの修正（1時間）
  ↓ 検証: npm run lint + 動作確認
Phase 3: コード品質向上（2時間）
  ↓ 検証: npm run build + 全機能テスト
Phase 4: ドキュメント更新（30分）
  ↓ 検証: レポート作成
```

---

## 効率的なリファクタリング手法

### **手法1: Lint駆動リファクタリング（最も効率的）**

#### **ステップ1: 全体像の把握**

```bash
# 1. Lintエラーを全て洗い出す
npm run lint > lint-errors.txt

# 2. エラーをカテゴリ分類
# - 環境設定の問題（server/ など）
# - 未使用変数
# - React Hooks警告
# - セキュリティ問題
```

#### **ステップ2: 優先順位の決定**

```
優先度1（即座に修正）: 環境設定の問題
  → globalIgnores でサクッと解決
  
優先度2（1日以内）: セキュリティ・バグリスク
  → プロトタイプメソッド、React Hooks警告
  
優先度3（1週間以内）: コード品質
  → 未使用変数の削除
```

#### **ステップ3: AIに依頼（ドキュメント参照付き）**

```
@docs/CODING_RULES.md @docs/ARCHITECTURE.md を参照して、
以下のLintエラーを修正してください:

1. src/shared/services/firestore.js:118
   - エラー: Do not access Object.prototype method 'hasOwnProperty'
   - 修正方法: Object.hasOwn() を使用
   - 条件: 既存の動作を変えないこと

2. src/features/collaboration/hooks/useParticipants.js:46
   - エラー: 'db' is defined but never used
   - 修正方法: インポートから削除
   - 条件: 他の部分で db が必要ないか確認

修正後、npm run lint で検証してください。
```

#### **ステップ4: 検証と反復**

```bash
# 修正後に検証
npm run lint

# エラーが減ったか確認
# 27個 → 16個 → 5個 → 0個

# 動作確認
npm run dev
# 全機能をブラウザでテスト
```

---

### **手法2: ドキュメント駆動リファクタリング**

#### **ステップ1: 仕様ドキュメントとの照合**

```
【ドキュメントを並べて比較】
1. @docs/01_current-spec.md を開く（現状仕様）
2. @docs/02_expected-spec.md を開く（期待仕様）
3. @docs/03_gap-list.md を開く（ギャップリスト）

【AIに依頼】
@docs/01_current-spec.md と @docs/02_expected-spec.md を比較して、
@src/features/study-room/ の実装で不足している機能をリストアップしてください。

特に以下の点に注目:
- ホスト退出時の権限移譲（現在未実装）
- 無人ルームの自動終了（現在未実装）
- participantsCount の不整合問題
```

#### **ステップ2: ギャップの優先順位決定**

```
【AIに依頼】
@docs/03_gap-list.md を参照して、
大学テスト導入前に必須の機能（Must項目）を
実装順序と工数見積もり付きでリストアップしてください。

依存関係も考慮してください:
例: 「ホスト権限移譲」を実装する前に
    「ホストの退出ボタン」が必要
```

#### **ステップ3: 段階的な実装**

```
【AIに依頼（Phase 1）】
@docs/02_expected-spec.md の #5（入室前のカメラ/マイク設定）を実装してください。

参照ドキュメント:
- @docs/ARCHITECTURE.md（Feature-based architecture に従う）
- @docs/CODING_RULES.md（コーディング規約に準拠）
- @docs/01_current-spec.md（既存の動作を理解）

実装後:
1. npm run lint で検証
2. 動作確認手順を提示
3. リファクタリングレポートを作成
```

---

### **手法3: バグ駆動リファクタリング**

#### **ステップ1: バグの文書化**

```
【AIに依頼】
現在のアプリで発生しているバグをリストアップしてください。

確認方法:
1. @docs/bugs.md を確認
2. npm run lint で潜在的な問題を検出
3. @docs/technical-analysis/ の既知の問題を確認
4. @docs/01_current-spec.md の「既知の制約・制限」を確認

優先度を付けて、修正計画を作成してください。
```

#### **ステップ2: バグの影響範囲分析**

```
【AIに依頼】
@docs/technical-analysis/2025-10-21_livekit-reload-issue-analysis.md を参照して、
LiveKitリロード問題の修正提案3つ（提案1〜3）を実装してください。

実装前に:
1. 影響範囲を分析
2. テストケースを作成
3. ロールバック手順を確認

実装後:
1. 全テストケースをパス
2. パフォーマンス測定
3. レポート更新
```

---

### **手法4: データ駆動リファクタリング**

#### **ステップ1: データ構造の文書化**

```
【AIに依頼】
現在のFirestore データベース構造を文書化してください。

出力フォーマット:
- TypeScript形式のインターフェース定義
- 各フィールドの説明
- デフォルト値
- 制約条件

参照:
@src/shared/services/firestore.js（defaultRoom, defaultParticipant）

出力先:
docs/06_api-spec.md
```

#### **ステップ2: データ不整合の検出と修正**

```
【AIに依頼】
@docs/06_api-spec.md を参照して、
participantsCount の不整合問題を修正してください。

修正方法:
1. Firebase Functions を使った自動カウント管理
2. または、クライアント側での動的カウント
3. 両方の実装を提示して、推奨案を選択

実装条件:
- 既存の動作を壊さない
- パフォーマンスへの影響を最小化
- テストケースを含める
```

---

## ドキュメント活用戦略

### **戦略1: 3層ドキュメント構造の活用**

```
【レイヤー1: 現状理解】
1. @docs/01_current-spec.md      ← 「今どうなっているか」
2. @docs/tech-stack.md           ← 「何を使っているか」
3. @docs/ARCHITECTURE.md         ← 「どう設計されているか」

【レイヤー2: 目標設定】
1. @docs/02_expected-spec.md     ← 「何を作るべきか」
2. @docs/03_gap-list.md          ← 「何が足りないか」
3. @docs/PROJECT_OVERVIEW.md     ← 「優先順位は何か」

【レイヤー3: 実装ガイド】
1. @docs/CODING_RULES.md         ← 「どう書くべきか」
2. @docs/AI_GUIDELINES.md        ← 「AIにどう依頼するか」
3. @docs/TEAM_DEVELOPMENT.md     ← 「チームでどう開発するか」
```

### **戦略2: AIへの効果的な指示パターン**

#### **パターンA: 問題検出→修正**

```
【ステップ1: 問題検出】
@docs/01_current-spec.md と @docs/02_expected-spec.md を比較して、
実装されていない機能をリストアップしてください。

【ステップ2: 優先順位決定】
@docs/03_gap-list.md の Must 項目のうち、
実装が最も簡単なものを3つ選んでください。
理由と工数見積もりも含めて。

【ステップ3: 実装】
選んだ機能のうち1つを実装してください。
@docs/ARCHITECTURE.md と @docs/CODING_RULES.md に従うこと。
```

#### **パターンB: Lint駆動**

```
【ステップ1: エラー検出】
npm run lint を実行して、エラーをカテゴリ別に分類してください。

【ステップ2: 優先度決定】
セキュリティ > バグリスク > コード品質 の順で優先度を付けてください。

【ステップ3: 一括修正】
高優先度のエラー（5個）を一括で修正してください。
@docs/CODING_RULES.md のスタイルガイドに従うこと。

修正後、npm run lint で検証してください。
```

#### **パターンC: 機能追加**

```
【ステップ1: 仕様理解】
@docs/02_expected-spec.md の #5（入室前のカメラ/マイク設定）を
実装する前に、以下を分析してください:
1. 既存のカメラ/マイク制御コードの場所
2. MediaDevices API の使用箇所
3. 必要な新規コンポーネント

【ステップ2: 設計】
@docs/ARCHITECTURE.md の Feature-based architecture に従って、
新機能のフォルダ構成を提案してください。

【ステップ3: 実装】
提案した設計で実装してください。
@docs/CODING_RULES.md に準拠すること。

【ステップ4: 検証】
1. npm run lint でエラーなし
2. 動作確認手順を提示
3. @docs/refactoring-reports/ にレポート作成
```

---

## 具体的なワークフロー

### **ワークフロー1: Lint駆動リファクタリング（最速・最効率）**

#### **全体の流れ（所要時間: 4-6時間）**

```
┌─────────────────────────────────────┐
│ Phase 1: 準備（10分）                │
├─────────────────────────────────────┤
│ 1. npm run lint 実行                │
│ 2. エラーを分類                      │
│ 3. 優先順位決定                      │
└─────────────────────────────────────┘
         ↓
┌─────────────────────────────────────┐
│ Phase 2: 環境設定（5分）             │
├─────────────────────────────────────┤
│ AI指示:                              │
│ 「eslint.config.js の globalIgnores │
│  に 'server' を追加してください」   │
│                                      │
│ 検証: npm run lint                  │
│ 結果: 27個 → 16個                   │
└─────────────────────────────────────┘
         ↓
┌─────────────────────────────────────┐
│ Phase 3: 高優先度修正（1-2時間）     │
├─────────────────────────────────────┤
│ AI指示:                              │
│ 「@docs/CODING_RULES.md を参照して、│
│  以下の5つのエラーを修正:           │
│  1. firestore.js:118 (プロトタイプ) │
│  2-5. React Hooks警告（4個）」      │
│                                      │
│ 検証: npm run lint + 動作確認       │
│ 結果: 16個 → 11個                   │
└─────────────────────────────────────┘
         ↓
┌─────────────────────────────────────┐
│ Phase 4: 未使用変数削除（1時間）     │
├─────────────────────────────────────┤
│ AI指示:                              │
│ 「未使用変数のLintエラー7個を       │
│  修正してください。本当に不要か     │
│  @docs/ARCHITECTURE.md で確認。」   │
│                                      │
│ 検証: npm run lint                  │
│ 結果: 11個 → 0個 ✅                 │
└─────────────────────────────────────┘
         ↓
┌─────────────────────────────────────┐
│ Phase 5: 全体検証（30分）            │
├─────────────────────────────────────┤
│ 1. npm run build:dev                │
│ 2. npm run dev で全機能テスト       │
│ 3. ブラウザコンソールでエラー確認   │
└─────────────────────────────────────┘
         ↓
┌─────────────────────────────────────┐
│ Phase 6: ドキュメント化（30分）      │
├─────────────────────────────────────┤
│ AI指示:                              │
│ 「@docs/templates/REFACTORING_      │
│  REPORT.md を使って、今回の修正を   │
│  レポートにまとめてください。」     │
└─────────────────────────────────────┘
```

---

### **ワークフロー2: 仕様駆動リファクタリング（仕様のずれを修正）**

#### **全体の流れ（所要時間: 1-2日）**

```
┌─────────────────────────────────────┐
│ Phase 1: 現状と期待のギャップ分析   │
│         （1時間）                    │
├─────────────────────────────────────┤
│ AI指示:                              │
│ 「@docs/01_current-spec.md と       │
│  @docs/02_expected-spec.md を比較。│
│                                      │
│  以下の観点で分析:                  │
│  1. 実装されていない機能            │
│  2. 仕様と異なる動作                │
│  3. 不整合なデータ                  │
│                                      │
│  結果を表形式でまとめてください。」 │
│                                      │
│ 出力: ギャップ分析レポート          │
└─────────────────────────────────────┘
         ↓
┌─────────────────────────────────────┐
│ Phase 2: 優先順位とロードマップ     │
│         （30分）                     │
├─────────────────────────────────────┤
│ AI指示:                              │
│ 「Phase 1 の分析結果をもとに、      │
│  @docs/03_gap-list.md の Must 項目を│
│  実装順序と依存関係を考慮して       │
│  並べ替えてください。                │
│                                      │
│  各項目に:                           │
│  - 工数見積もり（時間）             │
│  - 依存関係                          │
│  - 技術的課題                        │
│  を追加。」                          │
│                                      │
│ 出力: 実装計画書                     │
│ 保存先: docs/04_implementation-     │
│         plan.md                      │
└─────────────────────────────────────┘
         ↓
┌─────────────────────────────────────┐
│ Phase 3: 実装（機能ごとに反復）     │
│         （機能により異なる）         │
├─────────────────────────────────────┤
│ 【機能1: 入室前カメラ/マイク設定】  │
│                                      │
│ AI指示:                              │
│ 「@docs/02_expected-spec.md #5 と   │
│  @docs/ARCHITECTURE.md を参照して、 │
│  入室前のカメラ/マイク設定を実装。  │
│                                      │
│  実装箇所:                           │
│  - src/features/study-room/         │
│    components/home/MediaSettings.jsx│
│  - src/features/study-room/         │
│    hooks/home/useMediaSettings.js   │
│                                      │
│  条件:                               │
│  - MediaDevices API を使用          │
│  - ブラウザ権限エラーを適切に処理   │
│  - localStorage に設定を保存        │
│  - 既存の動作を壊さない」            │
│                                      │
│ 検証:                                │
│ 1. npm run lint                     │
│ 2. カメラ/マイクの許可・拒否テスト  │
│ 3. 設定が入室時に反映されるか確認   │
└─────────────────────────────────────┘
         ↓
┌─────────────────────────────────────┐
│ Phase 4: ドキュメント更新            │
│         （各機能完了後）             │
├─────────────────────────────────────┤
│ AI指示:                              │
│ 「今実装した機能について:           │
│  1. @docs/01_current-spec.md 更新   │
│  2. @docs/03_gap-list.md で完了済み │
│     にマーク                         │
│  3. リファクタリングレポート作成    │
│                                      │
│  @docs/templates/REFACTORING_       │
│  REPORT.md を使用。」               │
└─────────────────────────────────────┘
```

---

### **ワークフロー3: パフォーマンス駆動リファクタリング**

#### **全体の流れ**

```
┌─────────────────────────────────────┐
│ Phase 1: パフォーマンス測定          │
├─────────────────────────────────────┤
│ AI指示:                              │
│ 「@src/ 配下のコードで、             │
│  パフォーマンス問題がありそうな      │
│  箇所を検出してください:             │
│                                      │
│  検出項目:                           │
│  - 不要な再レンダリング              │
│  - 重い計算の繰り返し                │
│  - メモリリーク                      │
│  - 大きなファイル（500行以上）       │
│                                      │
│  各項目に優先度を付けてください。」  │
└─────────────────────────────────────┘
         ↓
┌─────────────────────────────────────┐
│ Phase 2: 最適化の実装                │
├─────────────────────────────────────┤
│ AI指示:                              │
│ 「VideoCallRoom.jsx (1,537行)を     │
│  @docs/ARCHITECTURE.md に従って     │
│  以下に分割してください:             │
│                                      │
│  1. useVideoTracks.js               │
│  2. useAudioTracks.js               │
│  3. useLiveKitConnection.js         │
│                                      │
│  既存の動作を維持すること。          │
│  各ファイルは200行以下に。」         │
└─────────────────────────────────────┘
```

---

## チェックポイント

### **各Phase完了時の必須チェック**

```
□ npm run lint でエラーなし
□ npm run build:dev が成功
□ ブラウザコンソールでエラーなし
□ 既存機能が全て動作する
□ 新機能が期待通りに動作する（追加の場合）
□ ドキュメントが更新されている
```

### **最終チェックリスト**

```
□ 全てのPhaseが完了
□ Lintエラー: 0個
□ ビルドエラー: 0個
□ ランタイムエラー: 0個
□ @docs/01_current-spec.md が最新
□ リファクタリングレポート作成済み
□ Gitコミットメッセージが適切
□ チームメンバーに共有済み
```

---

## 実践例: 今すぐ始められるリファクタリング

### **例1: Lintエラーを今日中に全て修正する**

```markdown
【AIへの指示（コピペして使える）】

@docs/CODING_RULES.md @docs/ARCHITECTURE.md を参照して、
以下の手順でLintエラーを修正してください:

## Phase 1: 環境設定（5分）
eslint.config.js の globalIgnores に 'server' を追加

検証: npm run lint
期待: 27個 → 16個

## Phase 2: 高優先度エラー修正（1時間）
1. src/shared/services/firestore.js:118
   - hasOwnProperty を Object.hasOwn に変更
2. React Hooks警告 4個を修正
   - 依存配列に不足している変数を追加
   - 必要に応じて useCallback でメモ化

検証: npm run lint + 動作確認
期待: 16個 → 11個

## Phase 3: 未使用変数削除（1時間）
7個の未使用変数を削除
- 本当に不要か各ファイルのコンテキストで確認
- 将来使う予定があれば大文字変数名に変更

検証: npm run lint
期待: 11個 → 0個 ✅

## Phase 4: レポート作成（30分）
@docs/templates/REFACTORING_REPORT.md を使用して、
docs/refactoring-reports/2025-10-21_lint-error-fixes.md
を更新してください。

各Phaseの修正内容、ビフォー・アフター、
動作確認結果を含めること。

---

条件:
- 既存の動作を絶対に壊さない
- 各Phase完了後に必ず検証
- エラーが出たら次に進まない
```

---

### **例2: participantsCount不整合を修正する**

```markdown
【AIへの指示】

@docs/technical-analysis/ と @docs/01_current-spec.md を参照して、
participantsCount の不整合問題を修正してください。

## 分析フェーズ（30分）
1. 現在の実装を分析
   @src/features/collaboration/hooks/useParticipants.js
2. 問題が発生するシナリオを特定
3. 3つの解決策を提案（メリット・デメリット付き）

## 実装フェーズ（2時間）
推奨案を実装:
- 方法1: Firebase Functions（理想）
- 方法2: クライアント側での動的カウント（現実的）
- 方法3: 退出前の明示的更新（最低限）

優先順位: 方法2 → 動作確認 → 問題あれば方法1

条件:
- @docs/ARCHITECTURE.md の設計原則に従う
- パフォーマンスへの影響を最小化
- ホーム画面の表示速度を維持

## 検証フェーズ（1時間）
テストシナリオ:
1. 複数人入室・退室を繰り返す
2. 全員退室後のカウント確認
3. ホーム画面でのリアルタイム更新確認

## ドキュメントフェーズ（30分）
1. @docs/01_current-spec.md を更新
   - participantsCount の挙動を正確に記載
2. 技術分析レポート作成
   - docs/technical-analysis/2025-10-21_participantscount-fix.md
```

---

### **例3: 新機能追加（入室前カメラ/マイク設定）**

```markdown
【AIへの指示】

@docs/02_expected-spec.md #5 を実装してください。

## 事前準備フェーズ（1時間）
1. @docs/ARCHITECTURE.md を参照して、フォルダ構成を設計
2. 既存のカメラ/マイク制御コードを調査
   @src/features/video-call/components/VideoCallRoom.jsx
3. MediaDevices API の使用方法を調査
4. 実装計画書を作成

## 実装フェーズ（3時間）
作成するファイル:
- src/features/study-room/components/home/MediaSettings.jsx
- src/features/study-room/hooks/home/useMediaSettings.js
- src/features/study-room/constants/media.js

実装内容:
1. MediaDevices API でカメラ/マイク一覧取得
2. ON/OFF設定UIの追加（ホーム画面）
3. localStorage に設定を保存
4. VideoCallRoom で設定を読み込んで適用

条件:
- @docs/CODING_RULES.md のスタイルガイドに準拠
- ブラウザ権限エラーの適切な処理
- 既存のビデオ通話機能を壊さない

## テストフェーズ（1時間）
1. カメラOFF設定で入室 → カメラがOFFか確認
2. マイクOFF設定で入室 → マイクがOFFか確認
3. ブラウザ権限拒否時のUI確認
4. 設定がlocalStorageに保存されるか確認

## ドキュメントフェーズ（1時間）
1. @docs/01_current-spec.md を更新
   - 2.1 に「入室前設定機能」を追加
2. @docs/03_gap-list.md を更新
   - 「入室前カメラ/マイク設定: 完了」にマーク
3. リファクタリングレポート作成
4. README.md の機能一覧を更新
```

---

## AIへの効果的な指示のテンプレート

### **テンプレート1: Lint修正**

```
@docs/CODING_RULES.md @docs/ARCHITECTURE.md を参照して、
以下のLintエラーを修正してください:

ファイル: [ファイルパス]
行番号: [行番号]
エラー: [エラーメッセージ]
修正方法: [具体的な修正方法]

条件:
- 既存の動作を変えない
- @docs/CODING_RULES.md に準拠
- npm run lint でエラーなしを確認

修正後、動作確認の手順も提示してください。
```

### **テンプレート2: 新機能追加**

```
@docs/02_expected-spec.md の #[番号]（[機能名]）を実装してください。

参照ドキュメント:
- @docs/ARCHITECTURE.md（設計方針）
- @docs/CODING_RULES.md（コーディング規約）
- @docs/01_current-spec.md（既存の動作理解）
- @docs/tech-stack.md（使用技術）

実装手順:
1. 設計: フォルダ構成とファイル一覧を提案
2. 実装: 段階的にファイルを作成
3. 検証: npm run lint + 動作確認
4. ドキュメント: レポート作成

条件:
- Feature-based architecture に従う
- 1ファイル200行以下
- UIとロジックを分離
- 既存機能を壊さない
```

### **テンプレート3: バグ修正**

```
@docs/technical-analysis/[レポート名].md を参照して、
提案[番号]を実装してください。

実装内容:
- [具体的な実装内容]

検証方法:
1. npm run lint
2. [テストシナリオ]
3. ブラウザコンソールでエラー確認

条件:
- 提案されたコードをベースにする
- パフォーマンスへの影響を考慮
- 実装後にレポートを更新
```

---

## 成功のための5つの原則

### **原則1: 常にドキュメントを参照させる**

```
悪い: 「これ直して」
良い: 「@docs/... を参照して、これを直して」
```

### **原則2: 小さな単位で検証**

```
悪い: 10個のファイルを一度に修正
良い: 1ファイルずつ修正 → 検証 → 次へ
```

### **原則3: 自動検証を活用**

```
毎回実行:
1. npm run lint
2. npm run build:dev
3. ブラウザでの動作確認
```

### **原則4: 必ずレポート化**

```
修正後:
1. ビフォー・アフターを記録
2. 学びを文書化
3. 次回への改善点を明記
```

### **原則5: 段階的な改善**

```
一度に完璧を目指さない:
Phase 1: 動くようにする
Phase 2: 正しくする
Phase 3: 速くする
Phase 4: 美しくする
```

---

## まとめ: 今日から始められる最速リファクタリング

### **今日の作業（4-6時間で完了）**

```bash
# 1. Lintエラー全修正（最優先）
AIに指示: 「Lint駆動リファクタリング」を実行
結果: 27個 → 0個

# 2. participantsCount修正（次に重要）
AIに指示: 「仕様駆動リファクタリング」でデータ不整合を解決
結果: ホーム画面の参加者数が正確に

# 3. ドキュメント更新
AIに指示: レポート作成とドキュメント同期
結果: 全ての変更が記録される
```

### **1週間後の状態**

```
✅ Lintエラー: 0個
✅ コード品質: 大幅向上
✅ データ不整合: 解消
✅ ドキュメント: 最新
✅ チーム: スムーズな共同開発
```

このワークフローを使えば、効率的かつ確実にプロジェクトを改善できます！🚀
